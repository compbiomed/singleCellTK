---
title: "Single Cell Analysis with Seurat using singleCellTK Package"
author: "`r params$authors`"
date: "`r format(Sys.time(), '%B %d, %Y')`"
params:
  subtitle: !r NULL
  authors: !r NULL
  sce: !r NULL
  biological.group: !r NULL
  phenotype.groups: !r NULL
  selected.markers: !r NULL
  clustering.resolution: 0.8
  variable.features: 2000
  pc.count: 10
  outputPath: !r NULL
  showSession: TRUE
  pdf: TRUE
output:
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
    theme: cosmo
    code_folding: hide
    self_contained: false
  pdf_document:
    toc: yes
subtitle: "`r params$subtitle`"
editor_options:
  chunk_output_type: console
bibliography: references.bib
csl: ieee.csl
---
# Seurat Run

## Introduction
[**Seurat**](https://satijalab.org/seurat/) [@Butler2018][@Stuart2019][@Satija2017][@Hao2021] is an R package that offers a streamlined workflow to analyze single cell genomics data including quality control, normalization, exploration of data and differential expression (marker selection), all integrated within the same package and can be run through separate functions provided for each step of the workflow which offers multiple algorithms/methods for each of the task in the workflow. The **singleCellTK** offers use of this workflow with [SingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) [@Amezquita2020] objects by providing wrapper functions to the methods available from Seurat. 

## Setup
We load the required libraries, read in the parameters and setup the variables to use with this analysis.
```{r parameters, include = TRUE, message=FALSE, warning=FALSE}
#Loading required libraries
library(Seurat)
library(dplyr)
library(cowplot)
library(RColorBrewer)
library(ggplot2)
library(knitr)
library(kableExtra)
library(SingleCellExperiment)
library(scater)
library(gridExtra)
library(grid)
library(ggplot2)
library(patchwork)
library(singleCellTK)

#Setting up parameters and loading data
group <- params$biological.group
selected_phenotypes <- params$phenotype.groups
Pre_selected_markers <- params$selected.markers
seurat.selected.resolution <- as.numeric(params$clustering.resolution)
seurat.selected.features.numbers <- as.numeric(params$variable.features)
initial.PC.numbers <- as.numeric(params$pc.count)
Custom_Markers <- Pre_selected_markers
data <- params$sce
sampleNames <- unique(colData(data)[[group]])
outputPath <- params$outputPath
showSession <- params$showSession
pdf <- params$pdf
```

```{r Seurat setup, include=FALSE}
# Knitr Global Options
dev <- ifelse(isTRUE(pdf), c("png"), c("png", "pdf"))
opts_chunk$set(
  echo = TRUE,
  cache = FALSE,
  cache.lazy = FALSE,
  cache.comments = FALSE,
  fig.align = "center",
  fig.keep = "all",
  dev = dev
)

 Numofbarbodes <- ncol(data)
 Numofbarbodes_filtered <- ncol(data)
 Numofmarkers <- nrow(data)
 Numofmarkers_filtered <- nrow(data)
 
 Numofsamples <- length(sampleNames)
 h.w.mtx = matrix(c(1,1,1,1,2,2,3,3,3,3, 1,2,3,4,3,3,3,3,3,4), nrow =2, byrow = TRUE)
 dimnames(h.w.mtx) = list(c("s.s.height.index", "s.s.width.index"))
 sample.separated.height = 6 * h.w.mtx[,Numofsamples][1]
 sample.separated.width = 6 * h.w.mtx[,Numofsamples][2]
 sample.separated.ncols = h.w.mtx[,Numofsamples][2]
 sample_coord_ratio = h.w.mtx[,Numofsamples][1]/h.w.mtx[,Numofsamples][2]
```

Number of Features/Genes/Markers: **`r Numofmarkers`** <br>
Number of Samples/Cells: **`r Numofbarbodes`** <br>
Selected Main Biological Group: **`r group`** <br>
Selected Additional Phenotype Groups: **`r selected_phenotypes`** <br>
Specified Custom Markers: **`r Pre_selected_markers`** <br>
Selected # of Variable Features to detect: **`r seurat.selected.features.numbers`** <br>
Selected # of PC: **`r initial.PC.numbers`** <br>
Selected Resolution for Clustering: **`r seurat.selected.resolution`** <br>

## Normalization
The global-scaling normalization method, "LogNormalize" was used to normalize the gene expression measurements for each cell by the total expression, multiplied by a scale factor of 10,000 (default), and log-transform the results.
```{r Seurat Normalization, message=FALSE}
normalizeParams <- list(
  inSCE = data,
  normalizationMethod = "LogNormalize",
  scaleFactor = 10000,
  verbose = FALSE
)
data <- do.call("seuratNormalizeData", normalizeParams)
```
```{r, include=FALSE}
normalizeParams$inSCE <- NULL
metadata(data)$seurat$sctk$report$normalizeParams <- normalizeParams
```

The selected assay **`r assayNames(data)[1]`** was normalized using **LogNormalize** method and the output normalized assay was stored back into the input object to be used in the downstream analysis.

## Feature Selection
A subset of features that exhibit high cell-to-cell variation in the dataset is calculated. By focusing on highly variable genes, we are able to better capture biological signal in single cell datasets.

Highly variables genes for downstream analysis were found by calculating the average expression and dispersion for each gene, and group them together, to calculate z-scores for dispersion within each grouping in order to control for the relationship between variability and average expression ([Macosko et al.](http://www.cell.com/abstract/S0092-8674(15)00549-8)).

A scatter plot of standardized variance (y-axis) versus average expression (x-axis) for each of the gene is visualized below. Top 10 most variable genes are labeled with their gene symbols and the points (genes) highlighted in red are considered as highly variable genes.

```{r Seurat Variable Genes, warning=FALSE}
hvgParams <- list(
  inSCE = data,
  hvgMethod = "vst", 
  hvgNumber = seurat.selected.features.numbers)
data <- do.call("seuratFindHVG", hvgParams)

num.variable.genes <- length(seuratVariableFeatures(data))

Labeled_Variable_data <- seuratPlotHVG(inSCE = data, labelPoints = 10)
Labeled_Variable_data
```
```{r, include=FALSE}
hvgParams$inSCE <- NULL
hvgParams$labelPoints <- 10
metadata(data)$seurat$sctk$report$hvgParams <- hvgParams
```

A total of **`r formatC(num.variable.genes, format="d", big.mark=",")`** top variable genes were selected for downstream analysis using the **vst** method. The **standardized variance** to **average expression** plot is visualized above where the **top `r formatC(num.variable.genes, format="d", big.mark=",")`** selected genes are highlighted in red and the **top 10** genes are labeled with their gene symbols. 

## Scaling
The previous step identifies and selects the top highly variable genes that represent the majority of the total variation (both biological and unwanted sources) in the dataset. As we intend to regress out the unwanted sources of the variation in the data and focus on the variation that most reflects the biological variability, we scale this variation with the expression level of the data. This approach shifts the mean expression for each gene across cells to 0, and scales the variance for expression of each gene across cells to 1.
```{r Seurat Scaling Data}
data <- seuratScaleData(inSCE = data, model = "linear", verbose = FALSE)
```
```{r, include=FALSE}
scaleParams <- list(
  model = "linear", 
  verbose = FALSE)
metadata(data)$seurat$sctk$report$scaleParams <- scaleParams
```

The data was scaled using **linear** transformation method. It was further **centered** and **trimmed** to a maximum value of **10** and stored back into the input data for downstream analysis.

## PCA {.tabset .tabset-fade}
Now we perform **principal component analysis** on the scaled data using the variable genes as input. However, **determining how many components to include in the downstream analysis is an important step**. A resampling **JackStraw** procedure ([Macosko et al.](http://www.cell.com/abstract/S0092-8674(15)00549-8)) is implemented to randomly permute (100 times) PCA reruns on a subset of the data (1% by default) to construct a 'null distribution' of gene scores. To overcome the extensive technical noise in any single feature of the scRNA-seq data, Seurat clusters cells based on their PCA scores, with each principal component essentially representing a 'metafeature' that combines information across a correlated feature set. Another heuristic method of determining how many components to use is to look at the plot of the standard deviations of the principal components known as the **Elbow Plot**.

```{r Seurat PCAs, JackStraw and Elbow plot, warning=FALSE}
pcaParams <- list(
  inSCE = data,
  nPCs = initial.PC.numbers,
  verbose = FALSE)
data <- do.call("seuratPCA", pcaParams)

jackStrawParams <- list(
  inSCE = data,
  useAssay = "seuratScaledData",
  dims = initial.PC.numbers,
  numReplicate = 100,
  propFreq = 0.025
)
data <- do.call("seuratComputeJackStraw", jackStrawParams)
```


Below we visualize the principal components from the PCA computation and see how much of heterogeneity is captured by each of the principal component and try to compute that how many of these components can be considered significant for downstream analysis.

### Elbow Plot {-}
An Elbow Plot is plotted between the number of principal components (x-axis) and their standard deviation (y-axis), where a clear elbow between the components shows the cut-off for the components that should be selected as significant.
```{r Seurat PCAs, Elbow Plot, warning=FALSE}
ElbowPlot <- seuratElbowPlot(
  inSCE = data,
  ndims = initial.PC.numbers,
  interactive = FALSE
)
ElbowPlot
```


### JackStraw Plot {-}
```{r Seurat PCAs, JackStraw Plot, warning=FALSE}
JackStrawPlot <- seuratJackStrawPlot(
  inSCE = data,
  dims = initial.PC.numbers,
  xmax = 0.05) + guides(col = guide_legend(ncol = 1)) + theme(
    legend.text = element_text(size = 6), legend.key.size = unit(0.2, "cm"))
JackStrawPlot
```

```{r Seurat Post PCA calculation, warning=FALSE}
PC_Matrix <- metadata(data)$seurat$obj@reductions$pca@jackstraw@overall.p.values

significant_PC <- which.min(PC_Matrix[,2] < 0.01) - 1
if (!exists("significant_PC") || significant_PC == 0){
  significant_PC <- initial.PC.numbers
}

PC.separated.height <- 3.5 * ceiling(initial.PC.numbers/3)
```
```{r, include=FALSE}
pcaParams$inSCE <- NULL
pcaParams$significant_PC <- significant_PC
metadata(data)$seurat$sctk$report$pcaParams <- pcaParams
```


### PC Heatmap {-}
The heatmap allows for easy exploration of the primary sources of heterogeneity. Both cells and features are ordered according to their PCA scores. This supervised analysis is still a valuable tool for exploring correlated feature sets.

```{r Seurat PC Heatmap, fig.height = PC.separated.height, fig.width = 15, warning=FALSE}
pcHeatmapParams <- list(
  inSCE = data,
  useAssay = "seuratScaledData",
  useReduction = "pca",
  dims = initial.PC.numbers,
  balanced = TRUE,
  ncol = 4,
  fast = FALSE
)
heatmap <- do.call("seuratComputeHeatmap", pcHeatmapParams)  
heatmap
```
```{r, include=FALSE}
pcHeatmapParams$inSCE <- NULL
metadata(data)$seurat$plots$heatmap <- pcHeatmapParams
```

## {-}


**Significant principal components will show a strong enrichment of genes with low p-values**, which can also be visualized as solid curve above the dashed line on the **Jackstraw plot** above. The PC cutoff could also be determined roughly by looking at where a clear elbow is depicted in the elbow plot. We use Jackstraw **P-value > 0.01** is used as the cutoff. The first **`r significant_PC`** principal components shown above appear to be significant, all well above the uniform distribution of p-values (dashed line) for each principal component. These **`r significant_PC`** principal components were determined to hold the true dimensionality of the dataset and will be used in the subsequent clustering analysis.

## Clustering
Seurat clusters cells based on their PCA scores, with each PC representing a 'metagene' that combines information across a correlated gene set. A graph-based clustering approach was used by applying a modularity optimization technique, the **Louvain algorithm**, to iteratively group cells together. Briefly, the method embeds the cells in a graph structure with edges drawn between cells with similar feature expression patterns, and then attempts to partition this graph into highly interconnected 'quasi-cliques' or 'communities'.

Seurat offers different non-linear dimensional reduction techniques including tSNE and UMAP. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimensionality reduction plots. 


### Different resolutions {.tabset .tabset-fade}
A **resolution parameter** is used for clustering in Seurat. This resolution sets the granularity of the clustering, with increased values leading to a greater number of clusters. The choice of resolution is slightly subjective and varies on the size of the dataset. Typically for larger datasets the optimal resolution often increases. The different clustering results are provided below using a set of different resolutions (ranging from 0.3 to 1.5) which can be visualized using tSNE and UMAP plots.

#### tSNE {.tabset .tabset-fade -}
We visualize the input dataset highlighted with cluster labels computed using multiple resolutions with tSNE that is considerably effective when data is high-dimensional and non-linear. More information on tSNE is provided in a separate section below.

##### RES 0.3 {-}
```{r Seurat tSNE resolution as 0.3, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.3, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 0.4 {-}
```{r Seurat tSNE resolution as 0.4, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.4, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 0.5 {-}
```{r Seurat tSNE resolution as 0.5, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.5, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 0.6 {-}
```{r Seurat tSNE resolution as 0.6, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.6, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 0.7 {-}
```{r Seurat tSNE resolution as 0.7, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.7, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 0.8 {-}
```{r Seurat tSNE resolution as 0.8, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.8, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 0.9 {-}
```{r Seurat tSNE resolution as 0.9, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.9, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 1.0 {-}
```{r Seurat tSNE resolution as 1.0, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.0, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 1.1 {-}
```{r Seurat tSNE resolution as 1.1, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.1, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 1.2 {-}
```{r Seurat tSNE resolution as 1.2, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.2, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 1.3 {-}
```{r Seurat tSNE resolution as 1.3, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.3, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 1.4 {-}
```{r Seurat tSNE resolution as 1.4, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.4, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```

##### RES 1.5 {-}
```{r Seurat tSNE resolution as 1.5, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.5, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p1
```


#### UMAP {.tabset .tabset-fade -}
UMAP can also be used for visualizing high-dimensional non-linear datasets, particularly it has an advantage of preserving the global structure of the dataset. More information on UMAP is provided in a separate section below.

##### RES 0.3 {-}
```{r Seurat UMAP resolution as 0.3, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.3, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 0.4 {-}
```{r Seurat UMAP resolution as 0.4, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.4, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 0.5 {-}
```{r Seurat UMAP resolution as 0.5, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.5, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 0.6 {-}
```{r Seurat UMAP resolution as 0.6, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.6, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 0.7 {-}
```{r Seurat UMAP resolution as 0.7, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.7, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 0.8 {-}
```{r Seurat UMAP resolution as 0.8, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.8, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 0.9 {-}
```{r Seurat UMAP resolution as 0.9, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 0.9, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 1.0 {-}
```{r Seurat UMAP resolution as 1.0, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.0, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 1.1 {-}
```{r Seurat UMAP resolution as 1.1, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.1, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 1.2 {-}
```{r Seurat UMAP resolution as 1.2, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.2, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 1.3 {-}
```{r Seurat UMAP resolution as 1.3, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.3, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 1.4 {-}
```{r Seurat UMAP resolution as 1.4, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.4, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

##### RES 1.5 {-}
```{r Seurat UMAP resolution as 1.5, eval = TRUE, warning = FALSE, message=FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = 1.5, verbose = FALSE)
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC)
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)

p1 <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
p2 <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
p2
```

# Seurat Results

## Selected Resolution {.tabset .tabset-fade}
Among different options of resolution above, a final resolution of **`r seurat.selected.resolution`** was chosen for downstream clustering to better reflect the data.

```{r Seurat Clustering, echo = TRUE, warning = FALSE}
data <- seuratFindClusters(data, useReduction = "pca", resolution = seurat.selected.resolution, verbose = FALSE)
numClusters <- length(unique(colData(data)[[paste0("Seurat_louvain_Resolution", seurat.selected.resolution)]]))
```
```{r, include=FALSE}
clusterParams <- list(
  resolution = seurat.selected.resolution
)
metadata(data)$seurat$sctk$report$clusterParams <- clusterParams
```
### tSNE {.tabset .tabset-fade -}
tSNE (Non-linear Dimensional Reduction) is a dimension reduction technique that places cells with similar local neighborhoods in high-dimensional space together in low-dimensional space. tSNE has been the default method for such task in the past years. Using default parameters, a final resolution of **`r seurat.selected.resolution`** and **`r significant_PC`** PCs was chosen to better reflect the data, visualized in the following tSNE.

```{r Seurat selected tsne}
data <- seuratRunTSNE(data, useReduction = "pca", dims = significant_PC)
```

#### Clusters {-}
Seurat clusters cells and assigned a cluster label to each cell. The following plot is the tSNE representation of the clustering results, colored by the cluster labels.
```{r Seurat tsne clusters 0.6}
tSNE_coloredby_cluster <- seuratReductionPlot(data, useReduction = "tsne", showLegend = TRUE)
tSNE_coloredby_cluster
```

#### Samples {-}

The clustering pattern above determined to hold the true dimensionality of the dataset was grouped by sample (color) to visualize sample clusters.

```{r Seurat tsne samples 0.6}
tSNE_coloredby_sample <- seuratReductionPlot(data, useReduction = "tsne", groupBy = group, showLegend = TRUE)
tSNE_coloredby_sample
```

#### Sample separated {-}

Seurat clusters cells and assigned a cluster label to each cell. The following plot is the tSNE representation of the clustering results, split by each samples.

```{r Seurat tsne samples separated 0.6}
# Plot each sample individually
tSNE_splitby_sample <- seuratReductionPlot(data, useReduction = "tsne", splitBy = group, showLegend = TRUE)
tSNE_splitby_sample
```

```{r Seurat tsne samples separated 0.6 phenotypes}
tSNE_coloredby_phenotype <- list()
for (i in 1:length(selected_phenotypes)){
  tSNE_coloredby_phenotype[[i]] <- seuratReductionPlot(data, useReduction = "tsne", groupBy = selected_phenotypes[i], showLegend = TRUE)
}
  
```

```{r Seurat tsne samples separated 0.6 phenotypes plot, results='asis', echo = FALSE}
for (i in 1:length(selected_phenotypes)){
  cat('\n\n#### Phenotype variable:  `', selected_phenotypes[i], '` {-} \n\n')
  print(tSNE_coloredby_phenotype[[i]])
}

```


### UMAP {.tabset .tabset-fade -}
The uniform manifold approximation and projection(UMAP) are another dimension reduction techniques to visualize the cell clusters in a low-dimensional space. Comparing to formal tSNE techniques, UMAP was considered to provide faster run times, better reproducibility and more meaningful inter-clustering distances and relationships. Using default parameters, a final resolution of **`r seurat.selected.resolution`** and **`r significant_PC`** PCs was chosen to better reflect the data, visualized in the following UMAP.

```{r Seurat UMAP selected resolution}
data <- seuratRunUMAP(data, useReduction = "pca", dims = significant_PC, verbose = FALSE)
```

#### Clusters {-}
Seurat clusters cells and assigned a cluster label to each cell. The following plot is the UMAP representation of the clustering results, colored by the cluster labels.
```{r Seurat UMAP clusters}
UMAP_coloredby_cluster <- seuratReductionPlot(data, useReduction = "umap", showLegend = TRUE)
UMAP_coloredby_cluster
```

#### Samples {-}
Seurat clusters cells and assigned a cluster label to each cell. The following plot is the UMAP representation of the clustering results, colored by the sample labels. 
```{r Seurat umap samples}
UMAP_coloredby_sample <- seuratReductionPlot(data, useReduction = "umap", groupBy = group, showLegend = TRUE)
UMAP_coloredby_sample
```

#### Sample separated {-}
Seurat clusters cells and assigned a cluster label to each cell. The following plot is the UMAP representation of the clustering results, split by each samples.

```{r Seurat umap samples separated}
UMAP_splitby_sample <- seuratReductionPlot(data, useReduction = "umap", splitBy = group, showLegend = TRUE)
UMAP_splitby_sample
```

```{r Seurat umap samples separated phenotype}
UMAP_coloredby_phenotype <- list()
for (i in 1:length(selected_phenotypes)){
  UMAP_coloredby_phenotype[[i]] <- seuratReductionPlot(data, useReduction = "umap", groupBy = selected_phenotypes[i], showLegend = TRUE)
}
  
```

```{r Seurat umap samples separated phenotype plots, results='asis'}
for (i in 1:length(selected_phenotypes)){
  cat('\n\n#### Phenotype variable:  `', selected_phenotypes[i], '` {-} \n\n')
  print(UMAP_coloredby_phenotype[[i]])
}

```


## Differential Expression **(`r group`)**
Gene markers defining **`r group`** were identified via differential expression using the **Wilcoxon rank sum test**. **Differentially expressed genes** were determined by genes detected at a **minimum percentage of 25% in either of the two groups of cells** (clusters being compared), and requiring **a gene to be differentially expressed (on average) at a 25% threshold between the two groups**.

```{r DEG, message=FALSE}
data <- seuratFindMarkers(data, allGroup = group, minPCT = 0.25, threshUse = 0.25,)
data.markers <- metadata(data)$seuratMarkers

write.csv(data.markers, file = paste0(outputPath, "DEGTableGroup", "-", gsub(" ", "_", Sys.Date()), ".csv"), row.names = FALSE)
```

### Gene Plots of Top Markers by Group {.tabset .tabset-fade}
Gene plot for the top marker genes in each of the identified clusters are visualized below through a feature plot, ridge plot, violin plot, dot plot or a heatmap plot.

#### Feature Plot {.tabset .tabset-fade .tabset-dropdown -}
A **feature plot** visualizes the **expression level** of a particular **gene marker in all cells of the data** on a **UMAP** plot. Here we visualize the **feature plots** of the **top 9 marker genes** in each unique **group** separately. Use the drop-down box to view top 9 markers from each of the group.
```{r DEG FeaturePlot, echo = TRUE, results = "asis", fig.height =9, fig.width = 9}

template <- "##### %s {.tabset .tabset-fade -}

"
template_inside <- "###### %s {-}

"
space <- " 

"
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
numClusters <- length(unique(data.markers$cluster))
for (currentCluster in 1:(numClusters)) {
  cat(sprintf(template, paste0("Cluster ", as.character(unique(data.markers$cluster))[currentCluster])))
  for (inside_count in 1:9){
    current_feature <- top9$gene.id[(9*currentCluster+inside_count)]
    cat(sprintf(template_inside, paste0(current_feature)))
    print(seuratGenePlot(data, plotType = "feature", features = current_feature, groupVariable = group, ncol = 1, cols = c("grey", "blue")))
    cat(space)
    }
  cat(space)
}
```


#### Ridge Plot {.tabset .tabset-fade .tabset-dropdown -}
A **ridge plot** visualizes the **expression level** of a particular **gene marker in all cells of the data** separated by **group** in the form of ridges. Here we visualize the **ridge plots** of the **top 9 marker genes** separated by **group**. Use the drop-down box to view top 9 markers from each of the group.
```{r DEG RidgePlot, echo = TRUE, results = "asis", fig.height =9, fig.width = 9}

template <- "##### %s {.tabset .tabset-fade -}
"
template_inside <- "###### %s {-}
"
space <- " 

"
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
numClusters <- length(unique(data.markers$cluster))
for (currentCluster in 1:(numClusters)) {
  cat(sprintf(template, paste0("Cluster ", as.character(unique(data.markers$cluster))[currentCluster])))
  for (inside_count in 1:9){
    current_feature <- top9$gene.id[(9*currentCluster+inside_count)]
    cat(sprintf(template_inside, paste0(current_feature)))
    print(seuratGenePlot(data, plotType = "ridge", features = current_feature, groupVariable = group, ncol = 1, cols = c("grey", "blue")))
    cat(space)
    }
  cat(space)
}
```

#### Violin Plot {.tabset .tabset-fade .tabset-dropdown -}
A **violin plot** visualizes the **expression level** of a particular **gene marker in all cells of the data** separated by **group**. Here we visualize the **violin plots** of the **top 9 marker genes** separated by **group**. Use the drop-down box to view top 9 markers from each of the group.
```{r DEG ViolinPlot, echo = TRUE, results = "asis", fig.height =9, fig.width = 9}

template <- "##### %s {.tabset .tabset-fade -}
"
template_inside <- "###### %s {-}
"
space <- " 

"
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
numClusters <- length(unique(data.markers$cluster))
for (currentCluster in 1:(numClusters)) {
  cat(sprintf(template, paste0("Cluster ", as.character(unique(data.markers$cluster))[currentCluster])))
  for (inside_count in 1:9){
    current_feature <- top9$gene.id[(9*currentCluster+inside_count)]
    cat(sprintf(template_inside, paste0(current_feature)))
    print(seuratGenePlot(data, plotType = "violin", features = current_feature, groupVariable = group, ncol = 1, cols = c("grey", "blue")))
    cat(space)
    }
  cat(space)
}
```


#### Dot Plot {-}
A **dot plot** visualizes the **change in the expression levels** of a particular **gene marker in all cells of the data** separated by **group** in the form of dots where the color of the dots indicate the expression level of that gene in a class and the size of the dot indicates the total percentage of the cells in that class.
```{r DEG DotPlot, fig.width=15, fig.height=8}
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
top9 <- top9$gene.id
seuratGenePlot(data, plotType = "dot", features = top9, groupVariable = group, ncol = 1, cols = c("grey", "blue")) + theme(axis.text.x = element_text(angle = 90, size = 7), legend.text = element_text(size = 8), legend.key.size = unit(0.4, "cm"), legend.position = "top")
```

#### Heatmap Plot {-}

```{r DEG HeatmapPlot, fig.width=15, fig.height=15}
top9DF <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
top9 <- top9DF$gene.id
groupHeatmapParams <- list(inSCE = data,
                           plotType = "heatmap", 
                           features = top9, 
                           groupVariable = group, 
                           ncol = 1, 
                           cols = c("grey", "blue"))
heatmap_complete <- do.call("seuratGenePlot", groupHeatmapParams)
heatmap_complete <- heatmap_complete + theme(axis.text.y = element_text(size = 8), legend.text = element_text(size = 8), legend.key.size = unit(0.5, "cm"), legend.position = "top")
heatmap_complete
```
```{r, include=FALSE}
metadata(data)$seurat$plots$top9 <- top9DF
metadata(data)$seurat$plots$group <- group
groupHeatmapParams$inSCE <- NULL
metadata(data)$seurat$plots$groupHeatmapParams <- groupHeatmapParams
```


### Table of Top Markers by Group
List of top genes for each clusters are saved as **top_genes_group.csv** which is available within the working directory.

List of top **10** genes for each group are listed below.

```{r Seurat Top Markers by group Table, echo = FALSE, results='asis'}
# Top genes table
top5 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(5, avg_logFC))
top10 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(10, avg_logFC))
top_all <- data.frame(data.markers %>% group_by(cluster))

write.csv(top10, file = paste0(outputPath, "DEGTableGroupTop10", "-", gsub(" ", "_", Sys.Date()), ".csv"), row.names = FALSE)

colNames<-colnames(top10)
kable(top10, style = 'html', row.names = FALSE) %>%
  kable_styling(bootstrap_options = "striped") %>%
  scroll_box(width = "100%", height = "500px")
```

## Differential Expression (Clusters)
Gene markers defining clusters via differential expression using the Wilcoxon rank sum test. Differentially expressed genes were determined by genes detected at a minimum percentage of 25% in either of the two groups of cells (clusters being compared), and requiring a gene to be differentially expressed (on average) at a 25% threshold between the two groups.

```{r DEG Clusters, echo = TRUE}
data <- seuratFindMarkers(data, minPCT = 0.25, threshUse = 0.25, verbose = FALSE)
data.markers <- metadata(data)$seuratMarkers

write.csv(data.markers, file = paste0(outputPath, "DEGTableClusters", "-", gsub(" ", "_", Sys.Date()), ".csv"), row.names = FALSE)
```


### Gene Plots of Top Markers by Clusters {.tabset .tabset-fade}
Gene plot for the top marker genes in each of the identified clusters are visualized below through a feature plot, ridge plot, violin plot, dot plot or a heatmap plot.

#### Feature Plot {.tabset .tabset-fade .tabset-dropdown -}
A **feature plot** visualizes the **expression level** of a particular **gene marker in all cells of the data** on a **UMAP** plot. Here we visualize the **feature plots** of the **top 9 marker genes** across all **clusters**. Use the drop-down box to view top 9 markers from each of the cluster.
```{r Seurat Top Markers by cluster feature, echo = TRUE, results = "asis", fig.height =9, fig.width = 9}

template <- "##### %s {.tabset .tabset-fade -}
"
template_inside <- "###### %s {-}
"
space <- " 

"
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
numClusters <- length(unique(data.markers$cluster))
for (currentCluster in 1:(numClusters)) {
  cat(sprintf(template, paste0("Cluster ", as.character(unique(data.markers$cluster))[currentCluster])))
  for (inside_count in 1:9){
    current_feature <- top9$gene.id[(9*currentCluster+inside_count)]
    cat(sprintf(template_inside, paste0(current_feature)))
    print(seuratGenePlot(data, plotType = "feature", features = current_feature, groupVariable = paste0("Seurat_louvain_Resolution", seurat.selected.resolution), ncol = 1, cols = c("grey", "blue")))
    cat(space)
    }
  cat(space)
}
```


#### Ridge Plot {.tabset .tabset-fade .tabset-dropdown -}
A **ridge plot** visualizes the **expression level** of a particular **gene marker in all cells of the data** separated by **clusters** in the form of ridges. Here we visualize the **ridge plots** of the **top 9 marker genes** across all **clusters**. Use the drop-down box to view top 9 markers from each of the cluster.
```{r Seurat Top Markers by cluster ridge, echo = TRUE, results = "asis", fig.height =9, fig.width = 9}

template <- "##### %s {.tabset .tabset-fade -}
"
template_inside <- "###### %s {-}
"
space <- " 

"
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
numClusters <- length(unique(data.markers$cluster))
for (currentCluster in 1:(numClusters)) {
  cat(sprintf(template, paste0("Cluster ", as.character(unique(data.markers$cluster))[currentCluster])))
  for (inside_count in 1:9){
    current_feature <- top9$gene.id[(9*currentCluster+inside_count)]
    cat(sprintf(template_inside, paste0(current_feature)))
    print(seuratGenePlot(data, plotType = "ridge", features = current_feature, groupVariable = paste0("Seurat_louvain_Resolution", seurat.selected.resolution), ncol = 1, cols = c("grey", "blue")))
    cat(space)
    }
  cat(space)
}
```

#### Violin Plot {.tabset .tabset-fade .tabset-dropdown -}
A **violin plot** visualizes the **expression level** of a particular **gene marker in all cells of the data** separated by **clusters**. Here we visualize the **violin plots** of the **top 9 marker genes** separated across all **clusters**. Use the drop-down box to view top 9 markers from each of the group.
```{r Seurat Top Markers by cluster violin, echo = TRUE, results = "asis", fig.height =9, fig.width = 9}

template <- "##### %s {.tabset .tabset-fade -}
"
template_inside <- "###### %s {-}
"
space <- " 

"
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
numClusters <- length(unique(data.markers$cluster))
for (currentCluster in 1:(numClusters)) {
  cat(sprintf(template, paste0("Cluster ", as.character(unique(data.markers$cluster))[currentCluster])))
  for (inside_count in 1:9){
    current_feature <- top9$gene.id[(9*currentCluster+inside_count)]
    cat(sprintf(template_inside, paste0(current_feature)))
    print(seuratGenePlot(data, plotType = "violin", features = current_feature, groupVariable = paste0("Seurat_louvain_Resolution", seurat.selected.resolution), ncol = 1, cols = c("grey", "blue")))
    cat(space)
    }
  cat(space)
}
```


#### Dot Plot {-}
A **dot plot** visualizes the **change in the expression levels** of a particular **gene marker in all cells of the data** separated by **clusters** in the form of dots where the color of the dots indicate the expression level of that gene in a cluster and the size of the dot indicates the total percentage of the cells in that cluster.
```{r DEG Clusters Dotplot, fig.width=15, fig.height=8}
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
top9 <- top9$gene.id
seuratGenePlot(data, plotType = "dot", features = top9, groupVariable = paste0("Seurat_louvain_Resolution", seurat.selected.resolution), ncol = 1, cols = c("grey", "blue")) + theme(axis.text.x = element_text(angle = 90, size = 7), legend.text = element_text(size = 8), legend.key.size = unit(0.4, "cm"), legend.position = "top")
```

#### Heatmap Plot {-}

```{r DEG Clusters HeatmapPlot, fig.width=15, fig.height=15}
top9 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(9, avg_logFC))
top9 <- top9$gene.id
seuratGenePlot(data, plotType = "heatmap", features = top9, groupVariable = paste0("Seurat_louvain_Resolution", seurat.selected.resolution), ncol = 1, cols = c("grey", "blue")) + theme(axis.text.y = element_text(size = 8), legend.text = element_text(size = 8), legend.key.size = unit(0.5, "cm"), legend.position = "top")
```

### Table of Top Markers by Cluster
List of top genes for each clusters are saved as **top_genes_cluster.csv** which is available within the working directory.

List of top **10** genes for each clusters are listed below.

```{r Seurat Top Markers by cluster Table, echo = FALSE, results='asis'}
# Top genes table
top5 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(5, avg_logFC))
top10 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(10, avg_logFC))
top_all <- data.frame(data.markers %>% group_by(cluster))

write.csv(top10, file = paste0(outputPath, "DEGTableClustersTop10", "-", gsub(" ", "_", Sys.Date()), ".csv"), row.names = FALSE)

colNames<-colnames(top10)
kable(top10, style = 'html', row.names = FALSE) %>%
  kable_styling(bootstrap_options = "striped") %>%
  scroll_box(width = "100%", height = "500px")
```


## Pre-Selected Markers {.tabset .tabset-fade .tabset-dropdown}
Relevant gene marker expressions were overlaid on top of the **`r numClusters`** clusters identified below. The following (*`r Custom_Markers`*) are genes from the list provided. If a pre-selected gene is not showing up below, it is considered not identified by seurat comparing to the list of genes differentially expressed. Regular expression was used to include similar markers that may contain selected marker names as partial of its name, but gene nomenclature issues may still cause some of pre-selected markers to fail to display.

```{r Seurat Custom markers backstage, include = FALSE, eval = TRUE}
markerGenes <- c()
for (marker in Custom_Markers){
    if (TRUE %in% grepl(marker, data.markers$gene.id, ignore.case = TRUE)){
        added_marker <- grep(marker, data.markers$gene.id, ignore.case = TRUE, value = TRUE)
        markerGenes <- append(markerGenes, added_marker)
    }
}
markerGenes <- unique(markerGenes)
numMarkerGenes <- length(markerGenes)
if (numMarkerGenes == 0){
  custom_eval = FALSE
} else {
  custom_eval = TRUE
}
```


```{r Seurat Custom markers, echo=TRUE, results = "asis", fig.height = 10, fig.width = 10, eval = custom_eval, echo = custom_eval}

template <- "### %s {.tabset .tabset-fade -}
"
template_inside <- "#### %s {-}
"
space <- " 

"
if (numMarkerGenes > 0){
  for (currentMarker in 1:numMarkerGenes) {
  cat(sprintf(template, paste0(markerGenes[currentMarker])))
  cat(sprintf(template_inside, paste0("All sample")))
  print(seuratGenePlot(data, features = markerGenes[currentMarker], cols = c("grey", "blue"), plotType = "feature", groupVariable = group, ncol = 1))
  cat(space)
  cat(sprintf(template_inside, paste0("Split by sample")))
    print(seuratGenePlot(data, features = markerGenes[currentMarker], plotType = "feature", cols = c("grey", "blue"), groupVariable = group, splitBy = group, ncol = 2))
  cat(space)
  cat(space)
  }
}
cat(space)
cat(space)
```

<br><br>

Plots for each of the pre-selected markers are saved in both .png and .pdf format. 

```{r Seurat Custom markers saving plots, echo=FALSE, dependson="Feature Plots", results='asis', eval = custom_eval, echo = custom_eval}
for(i in 1:numMarkerGenes) {
    # Create marker gene feature plot as PNG and PDF files
    custom_featureplot <- seuratGenePlot(data, plotType = "feature", features = markerGenes[i], cols = c("grey", "blue"), groupVariable = "Seurat_louvain_Resolution0.6")
}
```


## Output Data
The output SingleCellExperiment object **`r paste0(outputPath, "SCE_SeuratReport", "-", gsub(" ", "_", Sys.Date()), ".rds")`** is saved in the output directory which contains all of the stored computations and plots. This object can be loaded into the singleCellTK R toolkit to further inspect and visualize the data and plots through a interactive user interface. Additionally, all figures and tables have been stored to the output directory as well.

```{r Saving RDS Object, echo = TRUE}
saveRDS(data, paste0(outputPath, "SCE_SeuratReport", "-", gsub(" ", "_", Sys.Date()), ".rds"))
```

## Summary
The analysis of single cell data was performed by Seurat package. Firstly the data was normalized using LogNormalize method, variable features were identified using vst method and the data was then scaled using linear transformation method. PCA analysis was performed on the data and clustering was performed using multiple resolutions. The clusters were visualized using tSNE/UMAP methods and differential expression (marker selection) was run on the data. Gene marker plots were used to visualize the top genes sorted by adjusted p values. The figures, tables and the output SCE object were stored in the working directory which can be further visualized. The output object can be imported into the sctk shiny application to visualize and modify the workflow using the user interface.

# Session Information {-}
```{r session, eval = showSession, echo = showSession}
sessionInfo()
```

# References {-}
