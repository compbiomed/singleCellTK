---
title: "SingleCellTK - Console Analysis Tutorial"
author: "Yichen Wang"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE)
```

## Introduction

Single Cell Toolkit (singleCellTK, SCTK) is a package that works on single-cell RNA-seq (scRNAseq) dataset. SCTK allows users to import multiple datasets, perform quality control and a series of preprocessing, get clustering on cells and markers of clusters, and run various downstream analysis. Meanwhile, SCTK also wraps curated workflows for [celda](https://celda.camplab.net/v1.9.2/index.html) and [Seurat](https://satijalab.org/seurat/). 

This tutorial will take the real-world scRNAseq dataset as an example, which consists of 2,700 Peripheral Blood Mononuclear Cells (PBMCs) collected from a healthy donor. This dataset (PBMC3K) is available from 10X Genomics and can be found on the 10X website.

SCTK uses the [SingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) (SCE) object for management of expression matrices, feature/cell annotation data, and metadata. All of the functions have an SCE object as the first input parameter. The functions operate on a matrix stored in the `assay` slot of the SCE object. The parameter `useAssay` can be used to specify which matrix to use (the default is `"counts"`). Matrices can be of class `matrix` or `dgCMatrix` from the Matrix package. 

## Import Data

SCTK has wrapper functions for importing count matrix from the output of many types of processing tools. See the [documentation for importing data](import_data.html) for more detail. Here we use `importExampleData()` to load PBMC3k data from the Bioconductor package [TENxPBMCData](https://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html).  

Due to the nature of the algorithms of a part of the downstream analyses, it is **highly recommended** that users deduplicate the essential feature identifiers, which is stored as the `rownames` of the SCE object. An SCTK function, `dedupRowNames()` provides the functionality by adding `"-1", "-2", ..., -i"` suffix to the duplicated rownames.  

```{R import, message=FALSE, warning=FALSE, results='hold'}
library(singleCellTK)
sce <- importExampleData("pbmc3k")
sce <- dedupRowNames(sce)
```

## Quality Control (QC)

### Running QC methods

Quality control and filtering of cells is often needed before down-stream analyses such as dimensionality reduction and clustering. Typical filtering procedures include exclusion of poor quality cells with low numbers of counts/UMIs, estimation and removal of ambient RNA, and identification of potential doublet/multiplets. Many tools and packages are available to perform these operations and users are free to apply their tool(s) of choice. 

To perform QC, we suggest using the `runCellQC()` function. This is a wrapper for several methods for calculation of QC metrics, doublet detection, and estimation of ambient RNA. Below is a quick example of how to perform standard QC before heading to downstream analyses. If you have another preferred approach or your data has already been QC’ed, you can move to [Feature Selection section](#variable-feature-selection-1). For this tutorial, we will only run one doublet detection algorithm ([scDblFinder](https://bioconductor.org/packages/release/bioc/html/scDblFinder.html)) and one decontamination algorithm ([decontX](https://rdrr.io/bioc/celda/man/decontX.html)). For a full list of algorithms that this function runs by default, see ?runCellQC. We will also quantify the percentage of mitochondrial genes in each cell as this is often used as a measure of cell viability. 

```{R qc, message=FALSE, warning=FALSE, results='hold'}
# Get list of mitochondrial genes
sce <- importMitoGeneSet(sce, reference = "human", id = "symbol",
                         by = "rownames", collectionName = "mito")
# Run QC
sce <- runCellQC(sce, sample = NULL,
                 algorithms = c("QCMetrics", "scDblFinder", "decontX"),
                 collectionName = "mito",
                 geneSetListLocation = "rownames")
```

>**Note:** If you have cells from multiple samples stored in the SCE object, make sure to supply the sample parameter as the QC tools need to be applied to cells from each sample individually.

### Visualization

Individual sets of QC metrics can be plotted with specific functions. For example to plot distributions of total numbers of UMIs derived from `runPerCellQC()`, doublet scores from `runScDblFinder()`, and contamination scores from `runDecontX()` (all of which were run by the `runCellQC()` function), the following plotting functions can be used:

```{R plotPerCellQC, message=FALSE, warning=FALSE, fig.height=10, fig.width=8}
plotRunPerCellQCResults(sce)
```

```{R plotScDblFinder, message=FALSE, warning=FALSE, fig.height=7, fig.width=8}
plotScDblFinderResults(sce, reducedDimName = "decontX_UMAP")
```

```{R plottDecontX, message=FALSE, warning=FALSE, fig.height=7, fig.width=8}
plotDecontXResults(sce, reducedDimName = "decontX_UMAP")
```

A comprehensive HTML report can be generated to visualize and explore the QC metrics in greater detail:

```{R reportqc, eval=FALSE}
reportCellQC(sce)
```

### Filtering

After examining the distributions of various QC metrics, poor quality cells will need to be removed. Typically, thresholds for QC metrics should exclude cells that are outliers of the distribution (i.e. long tails in the violin or density plots). Cells can be removed using the `subsetSCECols()` function. Metrics stored in the `colData` slot of the SCE object can be filtered using the `colData` parameter. Here we will limit to cells with at least 600 counts and 300 genes detected, doublet score no more than 0.9, and at most 5% of mitochondrial genes detected:

```{R filter, message=FALSE, warning=FALSE}
sce <- subsetSCECols(sce, colData = c("total > 600", "detected > 300",
                                      "scDblFinder_doublet_score < 0.8",
                                      "subsets_mito_percent < 5"))

# See number of cells after filtering
ncol(sce)
```

## Normalization

After removing cells of low quality, we next need to normalize the feature expression matrix. SCTK has a generic wrapper function for various types of normalization, called `runNormalization()`. In this tutorial, we apply a global-scaling normalization method from [scater](https://bioconductor.org/packages/release/bioc/html/scater.html), `"logNormCounts"`. It normalizes the feature expression for each cell by the total expression, multiplies this by a scale factor, and log-transforms the result. Afterwards, we recommend running a z-score scaling on the log-normalized matrix prior to dimensionality reduction.  

```{R norm, message=FALSE, warning=FALSE, results='hold'}
sce <- runNormalization(sce, useAssay = "counts", outAssayName = "logcounts",
                        normalizationMethod = "logNormCounts")
sce <- runNormalization(sce, useAssay = "logcounts",
                        outAssayName = "logcounts_scaled", scale = TRUE)
```

>SCTK also supports a number of batch correction methods. Here we don't present the workflow because PBMC3k dataset only has one batch. For examples, please refer to the [document of batch correction](batch_correction.html).

## Variable Feature Selection

Selecting highly variable genes (HVG) for downstream analyses is recommended, since a subset of variable features can speed up the computation and reduce the noise being introduced. SCTK wraps the methods used in [Seurat](https://satijalab.org/seurat/) and [Scran](https://bioconductor.org/packages/release/bioc/html/scran.html). We recommend keeping at least 2,000-5,000 HVGs. In the example code, we use the "VST" method from Seurat, and select the top 2,000 genes. 

```{R hvg, message=FALSE, warning=FALSE}
sce <- seuratFindHVG(sce, useAssay = "counts", hvgMethod = "vst")
sce <- getTopHVG(sce, method = "vst", n = 2000, altExp = "hvg")
```

>**Note:** The row-subsetted matrix is stored in the “alternative experiment” slot (`altExp`) within the SCE object. This allows for a matrix with a different number of rows to be stored within the same SCE object (rather than creating two SCE objects). Some of the SCTK functions described in the next several sections will operate on a matrix stored in the `altExp` slot. The list of alternative experiments in an SCE can be view with `altExpNames(sce)`. In the future, there will be update to utilize the [ExperimentSubset](https://bioconductor.org/packages/release/bioc/html/ExperimentSubset.html) package for simpler operation on the subsets.  

## Linear Dimension Reduction

Although we have selected variable features, we would like to further reduce the noise. The next step is performing a principal component analysis (PCA), which creates new uncorrelated variables that successively maximize variance and finally increases the data interpretability but at the same time minimizes the information loss.  

In this tutorial, we use the wrapper function `scaterPCA()`, which comes from Scater. This function allows users to directly use a full-sized feature expression assay, as well as a subsetted expression matrix. Here, we will use the HVG selected in the last section and feed it to `useAltExp` argument.  

SCTK also supports Seurat's PCA and ICA method, which do a similar job. For Seurat methods, please refer to our [Seurat Curated Workflow](cnsl_seurat_curated_workflow.html).  

```{R setseed, message=FALSE, warning=FALSE, results="hold", echo=FALSE}
set.seed(12345)
```

```{R pca, message=FALSE, warning=FALSE, results="hold"}
sce <- runDimReduce(inSCE = sce, method = "scaterPCA", 
                    useAssay = "logcounts_scaled", useAltExp = "hvg",
                    reducedDimName = "PCA")
```

>Note: When using `useAltExp` argument in SCTK functions, users should also be aware of the `useAssay` argument. Usually when both are available, using only `useAssay` means using a full-sized feature expression matrix; using `useAssay` and `useAltExp` in the same call means using a subsetted expression matrix. In the latter scenario, `useAltExp` points to the alternative experiment stored in `altExp` slot of the SCE object, and `useAssay` points to the `assay` slot in the alternative experiment object.  

## Clustering

### Running SNN graph based clustering

SCTK supports clustering cells with Shared Nearest Neighbors (SNN) graph based methods and K-Means algorithm. For SNN graph based methods, we wrap the graph constructor from `scran` library, and have options of algorithms from `igraph` that can perform clustering on the graph. The result of clustering will be stored in the `colData` slot with variable name set by `clusterName`.  

Similarly as the steps above, `runScranSNN()` allows various types of input matrix, including log-normalized a full sized feature expression matrix or a subset of it, as well as a dimension reduction matrix. In this tutorial, we will use the PCA embedding generated in the previous section.  

```{R cluster, message=FALSE, warning=FALSE, results="hold"}
sce <- runScranSNN(sce, useReducedDim = "PCA", clusterName = "cluster", algorithm = "louvain", k = 4)
```

Meanwhile, in the Seurat Curated Workflow, the clustering is also done with an SNN graph, but the wrapper function alone, `seuratFindClusters()`, would be hard to use out of the curated workflow.  

In the other curated workflow that SCTK wraps, Celda Curated Workflow, we use a Bayesian hierarchical model that can bi-cluster features into modules and observations into subpopulations. For detail of this method, please refer to the [Celda Documentation](https://celda.camplab.net).   

### Visualization with UMAP

Uniform Manifold Approximation and Projection (UMAP) is one of the most commonly used methods to visualize the relationships between the cells in a 2-D embedding. This can be done using the function `getUMAP()`, which is a wrapper of `scater::calculateUMAP()` method. The result will be saved in `reducedDim` slot.  

Following the steps above, we will now use `useReducedDim` argument to pass the PCA embedding just generated to the function. This wrapper function also allows `useAssay` or `useAltExp` + `useAssay` method, while providing an option of running PCA dimension reduction on the expression matrix prior to the UMAP computation. In this way, however, the PCA will be done by `scater`, thus cannot be customized.  

SCTK also has the function for t-distributed Stochastic Neighbor Embedding (tSNE) method to create 2-D embedding for visualization, `getTSNE()`, where the general arguments for inputting a matrix work in the similar way.  

```{R umap, message=FALSE, warning=FALSE, results="hold"}
sce <- runDimReduce(inSCE = sce, method = "scaterUMAP", useReducedDim = "PCA", reducedDimName = "UMAP")
```

`plotSCEDimReduceColData()` is a generic plotting function that use the values stored in `reducedDim` slot as the axis to make 2-D scatter plots, and use the variables stored in `colData` slot to label each cell, by colors or shapes.  

Now, with the clustering result labeled for each cell and stored in the `colData` slot. We can plot the UMAP generated previously, with the clustering result labeled.  

```{R cluster_umap, message=FALSE, warning=FALSE, results="hold"}
plotSCEDimReduceColData(sce, colorBy = "cluster", reducedDimName = "UMAP", dotSize = 1)
```

## Marker Detection And Differential Expression

### Marker Detection

Users can next perform marker detection process with clusters labeled, or any other types of reasonable grouping of similar biological state of cells annotated in `colData` slot. SCTK finds markers for each cluster by running DE analysis on one cluster against all other clusters and iterating the same process for each cluster.  

```{R findMarker, message=FALSE, warning=FALSE, results="hold"}
sce <- findMarkerDiffExp(sce, useAssay = "logcounts", method = "wilcox",
                         cluster = "cluster",
                         log2fcThreshold = 0, fdrThreshold = 0.05,
                         minClustExprPerc = 0, maxCtrlExprPerc = 1,
                         minMeanExpr = 0)
```

By running `findMarkerDiffExp()`, SCTK stores a `data.table` of marker table to the `matadata` slot of the SCE object. The marker table will include all detected markers for each cluster and statistical values associated to each marker. To fetch the table, users can use the command below, and even add filtering parameters.  

```{R getMarkerTable, message=FALSE, warning=FALSE, results="hold"}
topMarkers <- findMarkerTopTable(sce, topN = 1, log2fcThreshold = 0, fdrThreshold = 0.05,
                                 minClustExprPerc = 0.5, maxCtrlExprPerc = 0.4,
                                 minMeanExpr = 0)
head(topMarkers, 10)
```

For visualization, SCTK has a specific heatmap plotting function for detected markers. The heatmap will take the log-normalized feature expression matrix for the values, and subset the features to only the top markers of each cluster. For the organization of the heatmap, the function groups the markers by the belonging to the clusters, and groups the cells, obviously, by clusters. Inside the grouping, the function finally performs the default hierarchical clustering. 

```{R markerHeatmap, message=FALSE, warning=FALSE, results="hold", fig.height= 8, fig.width=9}
markerHm <- plotMarkerDiffExp(sce, topN = 5, log2fcThreshold = 0, 
                              fdrThreshold = 0.05, minClustExprPerc = 0.5, 
                              maxCtrlExprPerc = 0.4, minMeanExpr = 0, 
                              rowLabel = TRUE)
```

### Customized Differential Expression Analysis

As we can easily tell from the heatmap above, "cluster 9" and "cluster 6" are having a very similar expression profile across the top markers detected. In order to further explore the difference between these two clusters, or any other two reasonable groups of cells, user can use the function `runDEAnalysis()`. 

`runDEAnalysis()` is a generic function for performing differential expression (DE) analysis between two selected groups of cells. This is also used by `findMarkerDiffExp()`. By running DE analysis, the function will take the normalized read count data and perform statistical analysis to discover quantitative changes in expression levels between selected groups. See here for the detail of [running DE analysis with SCTK](differential_expression.html). 

There are multiples ways to specify the groups of cells to be compared: by either directly specifying indices of cells, or selecting groups of cells with a categorical variable in `colData`. Additionally, `runDEAnalysis()` requires a relatively sophisticated inputs for naming the analyses, including the names of the two groups, and the name of one analysis, though these are not necessary for calling the algorithms alone. By requiring these, the results of the analyses can be stored with human readable identifiers and within one single SCE object, and can be more manageable. See the [DE documentation](differential_expression.html) for the detail. 

```{R de, message=FALSE, warning=FALSE, results="hold"}
sce <- runDEAnalysis(inSCE = sce, method = "wilcox", class = "cluster", classGroup1 = c(9), classGroup2 = c(6),
                 groupName1 = "cluster9", groupName2 = "cluster6", analysisName = "cluster9_VS_6")
```

Similarly to the marker detection section, SCTK also has a DE anaysis specific heatmap plotting function, `plotDEGHeatmap()`. Here, users can just easily enter the `analysisName` specified for one run and the function will automatically arrange the output. The heatmap is also splitted into a "checker board", by the "conditions" (i.e. the groups selected when running `runDEAnalysis()`) and the "regulation" (i.e. whether the log2 fold change is positive in "group1" against "group2"). 

```{R deHeatmap, message=FALSE, warning=FALSE, results="hold"}
deHm <- plotDEGHeatmap(sce, useResult = "cluster9_VS_6", rowLabel = TRUE)
```

## Cell Type Labeling

SCTK adopts [SingleR](https://bioconductor.org/packages/release/bioc/html/SingleR.html) method for labeling the cell types, and wraps the function in `runSingleR()`. Briefly, it labels each cell (or cluster) in users' datasets basing on similarity to a reference datasets. SingleR has recommended some datasets, so we enable choosing abbreviation name of them in argument `useBltinRef`. Please click on the function name for usage detail.  

>Note: Choosing a reference from the recommended builtin references would also require some prior knowledge of user data. **Users should choose a reference that covers the cell types possibly exist in user dataset.** SingleR works by scoring the similarity to each cell type and assigning a cell type by the highest score, regardless of how low the score is. Thus a beta cell from pancrea data cound even be wrongly labeled as a platelet if using a blood cell reference. 

```{R singleR, message=FALSE, warning=FALSE, results="hold"}
sce <- runSingleR(sce, useAssay = "logcounts", level = "fine")
```

The result of labeling will again be saved to `colData` slot of the SCE object. There will be multiple types of information being stored, including a scoring matrix named by `"SingleR_{ref}_{level}_scores"`, where `{ref}` refers to the reference selected, `{level}` refers to the `level` argument being passed to the function. And three `"SingleR_{ref}_{level}_{typeOfLabels}"` columns, where `{typeOfLabels}` includes `first.labels`, `labels`, `pruned.labels`. For the difference, please refer to `?SingleR::classifySingleR`.  

We can also plot the labeling on to the UMAP we got previously.  

```{R singleRUMAP, message=FALSE, warning=FALSE, fig.width=9}
plotSCEDimReduceColData(sce, colorBy = "SingleR_hpca_fine_pruned.labels", 
                        reducedDimName = "UMAP", dotSize = 1, legendSize = 8)
```

